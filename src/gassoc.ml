module type Assoc = sig
  type index
  type res

  val new_fresh : unit -> index
  val suspend : res -> int -> res
  val functorialize : res -> int list -> res

end

module GAssoc (B : Assoc) = struct

  type a = B.index
  type t = B.res
             
  type gassoc =
    |Node of a * t
    |Inner of (a * t) * (int * gassoc) list * ((int list) * gassoc) list

  let env = ref ([] : gassoc list)
                           
  exception Found of gassoc

  (** returns the association graph generated by the identifier v *)
  let assoc v g =
    let rec aux g =
      match g with
      |(Node(v',_) as res) when v = v' ->  raise (Found res)
      |Node(_,_) -> ()
      |(Inner((v',_),_,_) as res) when v = v' -> raise (Found res) 
      |Inner(_,l,l') ->
        let f = (fun x -> aux (snd x)) in
        begin List.iter f l; List.iter f l' end
    in
    try aux g; raise Not_found
    with Found r -> r

  (** returns the association graph generated by the identifier v in the environnement *)
  let assoc v =
    let rec aux env =
      match env with
      |[] -> raise Not_found
      |g::env ->
        try assoc v g
        with Not_found -> aux env
    in aux (!env)

  let top_value g =
    match g with
    |Node(_,res) -> res
    |Inner((_,res),_,_) -> res
    
  (** follow an already existing suspension edge or add a new one *)
  let rec suspend v i g =
    match g with
    |Node(w,value) when w = v ->
      let n = B.new_fresh() in
      let newval = B.suspend value i in
      Inner ((w,value) ,[i, Node (n, newval)],[]), Some newval
    |Node(_,_) as g -> g, None 
    |Inner((w,value),susp,func) as g when w = v ->
      begin
        try let res = List.assoc i susp in g, Some (top_value res)            
        with Not_found ->
          let n = B.new_fresh() in
          let newval = B.suspend value i in
          let susp = (i, Node (n, newval))::susp
          in Inner((w,value),susp,func),Some newval
      end
    |Inner(p,l,l') ->
      let rec suspend_list l =
        match l with
        |[] -> [],None
        |(k,g)::l ->
          let g,value = suspend v i g in
          match value with
          |None -> let l,res = suspend_list l in (k,g)::l, res
          |Some res -> (k,g)::l, Some res
      in    
      let l,r = suspend_list l in
      match r with
      | None -> let l',r = suspend_list l' in
                Inner(p,l,l'), r
      | Some res -> Inner(p,l,l'), Some res

  (** perform the suspension successively on all graphs on the list until finding the right one *)
  let suspend v i =
    let rec aux env =
      match env with
      |[] -> raise Not_found
      |g::env ->
        let g,r = suspend v i g
        in match r with
           |Some res -> g::env, res
           |None -> let env,res = aux env in g::(env),res
    in let newenv,res = aux (!env) in
       env:=newenv; res

  let rec functorialize v f g =
    match g with
    |Node(w,value) when w = v ->
      let n = B.new_fresh() in
      let newval = B.functorialize value f in
      Inner ((w,value),[],[f, Node (n, newval)]), Some newval
    |Node(_,_) as g -> g, None
    |Inner((w,value),susp,func) as g when w = v ->
      begin
        try let res = List.assoc f func in g, Some (top_value res)
        with Not_found ->
          let n = B.new_fresh() in
          let newval = B.functorialize value f in
          let func = (f, Node (n, newval))::func
          in Inner((w,value),susp,func), Some newval
      end
    |Inner(p,l,l') -> 
      let rec functorialize_list l =
        match l with
        |[] -> [],None
        |(k,g)::l ->
          let g,value = functorialize v f g in
          match value with
          |None -> let l,res = functorialize_list l in (k,g)::l, res
          |Some res -> (k,g)::l, Some res
      in
      let l,r = functorialize_list l in
      match r with
      |None -> let l',r = functorialize_list l' in
               Inner(p,l,l'), r
      |Some res -> Inner(p,l,l'),Some res

  let functorialize v f =
    let rec aux env =
      match env with
      |[] -> raise Not_found
      |g::env ->
        let g,r = functorialize v f g
        in match r with
           |Some res -> g::env, res
           |None -> let env,res = aux env in g::(env),res
    in let newenv,res = aux (!env) in
       env:=newenv; res
    
                                      
end

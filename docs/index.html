<!DOCTYPE html>
<html>
  <head>
    <title>CATT</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="catt.css"/>
    <script type="text/javascript" src="catt.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-96361958-1', 'auto');
  ga('send', 'pageview')

</script>
  </head>
  <body>
    <h1>CATT<br/>=^.^=</h1>
    <p style="text-align: center">
      Coherences for weak &omega;-categories.
    </p>

    <div id="toplevel"></div>

    <script type="text/javascript">
      function ku(event) {
        if (event.keyCode == 13)
          document.getElementById("send").click();
      }
      function init() {
        document.getElementById("input").onkeyup = ku;
      }
    </script>

<h2>Examples</h2>
    <p>
      Here are some examples to get used to the syntax and understand how the system works

<pre>
# Identity
coh id (x : *) : x -> x

# Composition
coh comp (x : *) (y : *) (f : x -> y) (z : *) (g : y -> z) : x -> z
</pre>
Redundant arguments must be kept implicit when using previously defined coherence
<pre>
# Left unit
coh unit-l (x : *) (y : *) (f : x -> y) : comp (id x) f -> f
# instead of "comp x x (id x) y f", one only writes "comp (id x) f"

# Right unit
coh unit-r (x : *) (y : *) (f : x -> y) : comp f (id y) -> f

# Unitor
coh unit-lr (x : *) : unit-l (id x) -> unit-r (id x)

# Associativity
coh assoc (x : *) (y : *) (f : x -> y) (z : *) (g : y -> z) (w : *) (h : z -> w) : comp (comp f g) h -> comp f (comp g h)
</pre>
The system also supports terms that are not immediately coherence
<pre>
# Identity over an identity
let id2 (x : *) = id (id x)

# Square of an endomorphism
let sq (x : *) (f : x -> x) = comp f f
</pre>
Operations are polymorphic with respect to the type of object 
<pre>
# 2-composition
let comp2 (x : *) (y : *) (f : x -> y) (f' : x -> y) (a : f -> f') (f'' : x -> y) (b : f' -> f'') = comp a b
## Even though a and b are 2-cells, one can still use comp to compose like the as usual 1-cells 
</pre>
More examples are available on <a href="https://github.com/ThiBen/catt/tree/master/examples"> my GitHub project page </a>
    </p>

    <h2>More details</h2>
    <ul>
      <li>
        The <a href="http://www.lix.polytechnique.fr/Labo/Samuel.Mimram/docs/mimram_catt.pdf">theory
          behind this</a>.
      </li>
      <li>
        The <a href="https://github.com/ThiBen/catt">source code</a>.
      </li>
      <li>
      <a href="https://github.com/smimram/catt">Samuel Mimram's implementation</a>.
      </li>
      <li>
	<a href="https://github.com/ericfinster/catt">Eric Finster's implementation</a>.
      </li>
    </ul>
  </body>
</html>
